<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Memorize</title>

  <!-- MathJax configuration must come before MathJAX is loaded even if async -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      TeX: {
        extensions: [ "color.js" ]
      }
    });
  </script>

  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_SVG" async></script>

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

  <link rel="stylesheet" href="css/tufte.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="favicon" href="favicon.ico">
</head>
<body>
  <article>
    <div style="display: none">
      $$
        \definecolor{us}{RGB}{239, 168, 86}
        \definecolor{other}{RGB}{74, 179, 193}
      $$
    </div>

   <img src="img/red_queen.512.png" alt="RedQueen"
       aria="hidden" class="red-queen-icon" />
    <h1 class="memorize">
        Memorize
    </h1>

    <p class="subtitle">
      An optimal algorithm for spaced repetition
    </p>
    <!--
    <ul class="subtitle">
      <li>Presented at <a href="http://www.wsdm-conference.org/2017/">WSDM, 2017</a>;</li>
      <li>Full paper at <a href="https://arxiv.org/abs/1610.05773">arxiv.org/abs/1610.05773</a>;</li>
      <li>Source code at <a href="https://github.com/Networks-Learning/RedQueen"><i class="fa fa-github"></i>Networks-Learning/RedQueen</a></li>
    </ul>
    -->

    <section>
      <h2>Introduction</h2>

      <p>
        It is <a href="https://www.gwern.net/Spaced\%20repetition">well known</a> that
        repeated and spaced reviews of knowledge is necessary for improving
        retention.
        However, it is unclear what is the best schedule for reviews is. Several
        heuristics have been suggested, but they lack guarantees of optimality.
          <label class="margin-toggle sidenote-number" for="sn-reviewing"></label>
          <input id="sn-reviewing" class="margin-toggle" type="checkbox">
          <span class="sidenote">
            See [TODO REFERENCES].
          </span>

        In this work, we will describe a way of coming up with an optimal
        scheduling algorithm which we name <div class="memorize">Memorize</div>.
      </p>

      <h2>Problem setup</h2>

      <p>
        Let us consider the problem of learning <em>one</em> knowledge item.
        We assume that we know how <em>difficult</em> learning the item is.
          <label class="margin-toggle sidenote-number" for="sn-item-difficulty"></label>
          <input id="sn-item-difficulty" class="margin-toggle" type="checkbox">
          <span class="sidenote">
            We will formalize these parameters later. These parameters
            can be estimated from a dataset of learning traces.
            Depending on the size of the dataset, these parameters can be
            user-specific, item-specific, or even user-item specific.
          </span>
        Our algorithm will determine the next-reviewing time. The learner will
        be <em>tested</em> at that time to see if he can recall the item and we
        will update our next-reviewing time based on that information.
      </p>

      <p>
        The objective of the algorithm is to keep the recall of the item high
        during the experiment duration \( (0, T] \) while minimizing the total
        number of reviews that the learner has to do.
      </p>

      <h3>Memory models</h3>
      <p>
        Before we can start talking about scheduling, we need a model of human
        memory, which can help us predict how humans forget. There are are
        multiple models of memory which can predict the probability of recall
        at time \( t \) given the past reviews of the item and its
        <em>difficulty</em>.

          <label class="margin-toggle sidenote-number" for="sn-memory-model"></label>
          <input id="sn-memory-model" class="margin-toggle" type="checkbox">
          <span class="sidenote">
            See [TODO REFERENCES for ACT-R, MCM, Exponential, Ebbinghaus].
          </span>
      </p>

      <p>
        We will assume that the probability of recall follows the analytically
        simple exponential decay model. In our paper, we have extended the
        analysis to more widely accepted power-law decay model of memory as
        well.
      </p>

      <p>
        In the exponential decay model of memory, we assume that probability of
        recall \( m(t) \) of an item immediate after a review is \( 1 \). Then,
        as the name suggests, the probability of recall \( m(t) \) decays
        exponentially with a forgetting rate \( n(t) \), which depends on the
        past reviews and the item difficulty:

        $$
        m(t) = e^{-n(t)(t - t_r)}
        $$

        Our estimate of the forgetting rate is adapted to be higher or lower
        depending on whether the learner managed to recall the item at a
        review or not:

        $$
        n(t + dt) = \begin{cases}
        (1 - \alpha) \times n(t) & \text{if item was recalled}\\
        (1 + \beta) \times n(t) & \text{if item was forgotten}
        \end{cases}
        $$

        \( \alpha \) and \( \beta \), as well as the initial difficulty \( n(0)
        \),  are parameters of the model which are derived from the dataset
        using Stochastic Gradient Decent using
        <a href="https://github.com/duolingo/halflife-regression">Halflife regression.</a>
      </p>

      <h2>Methodology</h2>

      <p>
        Contrary to the previous approaches which directly produce the optimal
        time to review either by discretizing time into fixed slots (e.g. hours
        or days) or by using a <em>thresholding</em> based strategy (which schedules
        review just when the recall probability is about to fall under a threshold),
        we produce the optimal <em>rate</em> of reviewing.
      </p>

      <p>
        This will allow us to formulate the problem as a <a href="shttps://en.wikipedia.org/wiki/Hamilton%E2%80%93Jacobi%E2%80%93Bellman_equation#Extension_to_stochastic_problems">stochastic control problem.</a>
        However, before that, we have to choose a loss function.
      </p>

      <p>
        We choose the following loss function

        $$
          \begin{align}
          \underset{u(0, T]}{\text{minimize}} &
          \quad \mathbb{E}_{\text{reviewing times}}\left[
                \int_{0}^{T} \left( \,(1 - m(t))^2(\tau) + \frac{1}{2} q\,u^2(\tau) \right) d\tau
              \right] \\
          \text{subject to} & \quad u(t) \geq 0 \quad \forall t \in (0, T]
          \end{align}
        $$

        This loss penalizes high probability of forgetting \( 1 - m(t) \) as well
        as high review rates \( \frac{1}{2} q\,u^2(t) \), with \( q \) acting
        as a parameter to trade off between these objectives.
      </p>

      <p>
        We integrate the this loss function over the experiment interval
        \( [0, T] \) and, since the future is stochastic, we attempt
        to find the reviewing rate \( u(t) \) for the item which minimizes the
        expectation of the integral.
      </p>

      <p>
        With this choice of the loss function, the optimization problem can be
        solved analytically by formulating the optimal cost-to-go, deriving a
        PDE using the <a href="https://en.wikipedia.org/w/index.php?title=Hamilton%E2%80%93Jacobi%E2%80%93Bellman_equation&wteswitched=1">Hamilton-Jacobi-Bellman equation</a>
        and then solving it.
      </p>

      <p>
        Finally, on solving the PDE, we arrive at the following elegant solution:

        $$
        \overbrace{u(t)}^{\text{reviewing intensity}} = \sqrt{1/q}\,\underbrace{(1 - m(t))}_{\text{Prob. of forgetting}}
        $$
      </p>

      <p>
        This function states that the rate at which <span class="us">the broadcaster</span> must post messages (i.e. the <em>urgency</em> of posting), should be proportional to how <em>bad</em> his rank \( r(t) \) is.
        Hence, he will have to post <em>faster</em> to stay where he originally was (i.e. at the top).
      </p>

      <p>
        Determining the rate requires only knowing the rank of
        <span class="us">the broadcaster</span> on the feed(s) of his follower(s).
        This information can be calculated in \( \mathcal{O}(1) \) time, given
        the stream of posts from <span class="other">other broadcasters</span>,
        the sampling, as shown <a href="#sampling">below</a>, too takes only
        \( \mathcal{O}(1) \) time, making this an efficient online algorithm
        for determining when-to-post.
      </p>

      <h2 id="sampling">From <em>rate-of-posting</em> to <em>when-to-post</em></h2>

      <p>
        <!--
        <label class="margin-toggle" for="eqn-user-rate">⊕</label>
        <input id="eqn-user-rate" class="margin-toggle" type="checkbox">
        <span class="marginnote">
        </span>
        -->

        Now that we know how <span class="us">the broadcaster</span> should
        regulate his messages, we have to determine when exactly should the next post be made.
      </p>

      <p>First, notice that \( u(t) \) changes only when \( r(t) \) changes and in steps of size \( \sqrt{{s}/{q}} \).</p>

      <p>
        Thanks to the superposition property of Poisson point processes
        we can treat each <em>jump</em> in \( u(t) \) as the start of a new Poisson process.
      </p>

      <figure>
        <label class="margin-toggle" for="superposition">⊕</label>
        <input id="superposition" class="margin-toggle" type="checkbox">
        <span class="marginnote">
          The process \( u(t) \) can be seen as a super-position of multiple
          Poisson processes starting at the times the rank \( r(t) \) changes,
          i.e. when <span class="other">other broadcasters</span> post
          messages.
        </span>
        <img src="img/superposition.svg"
             alt="u(t) is superposition of multiple point processes"
             class="centered width-75">
      </figure>

      <p>
        Now to draw the time of first event for \( u(t) \), i.e. when
        <span class="us">our broadcaster</span> posts, we can draw samples
        from all point processes and take the minimum.
      </p>

      <figure>
        <label class="margin-toggle" for="sampling-note">⊕</label>
        <input id="sampling-note" class="margin-toggle" type="checkbox">
        <span class="marginnote">
          Since \( u(t) \) is a sum of several independent Poisson processes,
          the first event which occurs according to it is the earliest of the
          first events of each of its components.
        </span>
        <img src="img/sampling.svg"
              alt="sampling u(t) involves taking the minimum of all samples for individual processes"
              class="centered width-75">
      </figure>

      <p>
        Since drawing one sample is an \( \mathcal{O}(1) \) operation, and we
        draw one sample each time <span class="other">other broadcasters</span>
        post, we only have to take \( \mathcal{O}(M(t_f)) \) samples.
      </p>

      <h2>Demo</h2>

      <p>Choose the metric you would like to see and press the <code>Play</code> button to start the demo.</p>

      <p class="metric-control">
        <span class="js-option option">
          <input id="avg_rank" type="radio" name="performance_metric" value="avg_rank" checked class="js-perf-metric">
          <label for="avg_rank">Rank \( r(t) \)</label>
        </span>
        <span class="js-option option">
          <input id="time_at_top" type="radio" name="performance_metric" value="time_at_top" class="js-perf-metric">
          <label for="time_at_top">Time at top \( \int_{0}^{t} \mathbb{I}(r(\tau) \lt 1)\, d\tau \)</label>
        </span>
      </p>



      <p class="pure-button-group centered sans" role="group" aria-label="interactive buttons">
        <button class="small pure-button button-play js-play">
          <i class="fa fa-play"></i> Play
        </button>
        <button class="small pure-button button-stop js-stop">
          <i class="fa fa-stop"></i> Stop
        </button>
      </p>

      <figure>
        <label class="margin-toggle" for="redqueen-demo-caption">⊕</label>
        <input id="redqueen-demo-caption" class="margin-toggle" type="checkbox">
        <span class="marginnote">
          Interactive demo showing the performance (i.e. \( r(t) \)) of
          <span class="red-queen">RedQueen</span> against a Poisson broadcaster
          (who posts at random times) against a bursty stream of tweets coming
          from other broadcasters.
        </span>

        <div class="long vis-aspect">
          <svg id="perf-1-vis" width="100%" class="content" viewBox="0 0 300 100"></svg>
        </div>

        <div class="long vis-aspect">
          <svg id="perf-2-vis" width="100%" class="content" viewBox="0 0 300 100"></svg>
        </div>

        <div class="equal-size">
          <div class="tall left vis-aspect">
            <svg class="content" id="feed-1-vis" viewBox="0 0 100 150"></svg>
          </div>
          <div class="tall right vis-aspect">
            <svg id="feed-2-vis" class="content" viewBox="0 0 100 150"></svg>
          </div>
        </div>
      </figure>

      <h2>More details</h2>

      <p>
        <a href="https://arxiv.org/abs/1610.05773">Our paper</a> contains a mathematical description of <span class="red-queen">RedQueen</span>,
        and several extensions including, but not limited to:
      </p>

      <ul>
        <li>Comparison against an Oracle and the state of the art and saw that our algorithm fared favourably.</li>
        <li>Extension to handle multiple users and to handle time varying weights for followers.</li>
        <li>Testing under <em>truthful what-if</em> conditions by playing back tweets on falls of followers of over 2000 Twitter users. <span class="red-queen">RedQueen</span> was able to obtain better average rank as well as higher time in the top-1 compared to the real users as well as against the current state of the art. </li>
      </ul>


      <h2>The Name <em class="red-queen">RedQueen</em></h2>

      <p>
        The name is taken from the <a href="https://en.wikipedia.org/wiki/Red_Queen">Red Queen's race</a>
        incident in <a href="https://en.wikipedia.org/wiki/Lewis_Carroll">Lewis Carroll</a>'s
        book <a href="https://en.wikipedia.org/wiki/Through_the_Looking-Glass">Through the Looking Glass</a>.
        In particular, the Queen's quote:
      </p>

      <div class="epigraph">
        <blockquote>
          "Now, here, you see, it takes all the running you can do, to keep in the same place."
          <footer>Red Queen</footer>
        </blockquote>
      </div>

      <h2>Authors</h2>

      <p>
      The webpage was created by <a href="https://musicallyut.in">Utkarsh Upadhyay</a>.
      The other authors of <span class="red-queen">RedQueen</span> are <a href="https://azarezade.github.io/">Ali Zarezade</a>, <a href="http://sharif.edu/~rabiee/">Hamid R. Rabiee</a>, and <a href="https://people.mpi-sws.org/~manuelgr/">Manuel Gommez-Rodriguez</a>.
      </p>
    </section>

    <hr>

    <section class="small-font">
      <h3>Acknowledgements</h3>
      <p>
        The <em class="red-queen">RedQueen</em> icon was made by <a href="http://www.flaticon.com/authors/zlatko-najdenovski" title="Zlatko Najdenovski">Zlatko Najdenovski</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a>. It is licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a>.

        <!-- Other icons made by <a href="http://www.freepik.com" title="Freepik">Freepik</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a> are licensed by <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a></div> -->
      </p>
    </section>

    <section>
      <h3>Source code</h3>
      <ul>
        <li><a href="https://github.com/Networks-Learning/RedQueen"><i class="fa fa-github"></i>Networks-Learning/RedQueen</a></li>
        <li><a href="https://github.com/Networks-Learning/RedQueen-website"><i class="fa fa-github"></i>Networks-Learning/RedQueen-website</a></li>
      </ul>
    </section>
  </article>

  <script src="js/main.js"></script>
  <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-8158678-1");
pageTracker._trackPageview();
} catch(err) {}
   </script>
</body>
</html>
